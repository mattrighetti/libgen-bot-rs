use std::time::Duration;

use sqlx::{postgres::PgPoolOptions, PgPool};

pub async fn init(db_url: &str) -> PgPool {
    let pg = PgPoolOptions::new()
        .max_connections(5)
        .acquire_timeout(Duration::from_secs(3))
        .connect(&db_url)
        .await
        .expect("can't connect to database.");

    run_migrations(&pg)
        .await
        .expect("cannot run migration on database.");

    pg
}

async fn run_migrations(db: &PgPool) -> Result<(), String> {
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS analytics (
            id       BIGINT GENERATED BY DEFAULT AS IDENTITY,
            user_id  INTEGER NOT NULL,
            msg_id   INTEGER NOT NULL,
            type     TEXT NOT NULL,
            utime    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
            PRIMARY KEY (id)
        )",
    )
    .execute(db)
    .await
    .map_err(|e| e.to_string())?;

    Ok(())
}

pub async fn register(
    db: &PgPool,
    chat_id: i64,
    message_id: i32,
    r#type: &str,
) -> Result<(), String> {
    log::debug!("inserting: {} {} {}", chat_id, message_id, r#type);

    sqlx::query("INSERT INTO analytics (user_id, msg_id, type) VALUES ($1,$2,$3)")
        .bind(chat_id)
        .bind(message_id)
        .bind(r#type)
        .execute(db)
        .await
        .map_err(|e| e.to_string())?;

    Ok(())
}
